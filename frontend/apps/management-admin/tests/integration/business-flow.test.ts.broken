/**
 * Business Flow Integration Tests
 * Tests complete business workflows end-to-end with real services
 */

import { getBusinessMonitor, BusinessOperationType } from '../../src/lib/business-performance-monitor';
import { getAuditLogger, AuditEventType } from '../../src/lib/audit-logger';
import { getMFAService, MFAMethod } from '../../src/lib/mfa-service';
import { getPWAManager } from '../../src/lib/pwa-manager';

describe('Business Flow Integration Tests', () => {
  beforeEach(() => {
    // Clear any stored state
    localStorage.clear();
    sessionStorage.clear();
    jest.clearAllMocks();
  });

  describe('Complete Authentication Flow', () => {
    test('should track full authentication journey', async () => {
      const monitor = getBusinessMonitor();
      const auditLogger = getAuditLogger();
      
      // Start login operation
      const loginOpId = monitor.startOperation(
        BusinessOperationType.LOGIN_ATTEMPT,
        { username: 'test@example.com' },
        'test-user-123'
      );

      // Add authentication checkpoints
      monitor.addCheckpoint(loginOpId, 'credentials_received');
      await auditLogger.log(AuditEventType.USER_LOGIN_FAILED, 'User attempted login', {},  ?  : {}, { severity: AuditSeverity.medium.toUpperCase() });

      monitor.addCheckpoint(loginOpId, 'credentials_validated');
      
      // Simulate MFA challenge
      monitor.addCheckpoint(loginOpId, 'mfa_challenge_sent');
      
      // Complete successful login
      monitor.completeOperation(loginOpId, true, undefined, undefined, {
        authMethod: 'password+mfa',
        sessionCreated: true
      });

      await auditLogger.log(AuditEventType.USER_LOGIN, 'User successfully logged in', {},  ?  : {}, { severity: AuditSeverity.low.toUpperCase() });

      // Verify operation was tracked
      const summary = monitor.getOperationSummary(BusinessOperationType.LOGIN_ATTEMPT);
      expect(summary.totalOperations).toBeGreaterThanOrEqual(1);
      expect(summary.successRate).toBeGreaterThan(0);
    });

    test('should handle failed authentication with monitoring', async () => {
      const monitor = getBusinessMonitor();
      const auditLogger = getAuditLogger();
      
      const loginOpId = monitor.startOperation(
        BusinessOperationType.LOGIN_ATTEMPT,
        { username: 'invalid@example.com' },
        'unknown-user'
      );

      monitor.addCheckpoint(loginOpId, 'credentials_received');
      
      // Simulate failed authentication
      monitor.completeOperation(loginOpId, false, 'Invalid credentials', 'INVALID_CREDENTIALS', {
        attemptCount: 1,
        ipAddress: '192.168.1.100'
      });

      await auditLogger.log(AuditEventType.SECURITY_VIOLATION, 'Failed login attempt with invalid credentials', {}, {
          username: 'invalid@example.com',
          ipAddress: '192.168.1.100'
        }
       ? {
          username: 'invalid@example.com',
          ipAddress: '192.168.1.100'
        }
       : {}, { severity: AuditSeverity.high.toUpperCase() });

      const summary = monitor.getOperationSummary(BusinessOperationType.LOGIN_ATTEMPT);
      expect(summary.totalOperations).toBeGreaterThanOrEqual(1);
    });
  });

  describe('Tenant Management Workflow', () => {
    test('should track complete tenant creation flow', async () => {
      const monitor = getBusinessMonitor();
      const auditLogger = getAuditLogger();
      
      // Start tenant creation
      const createOpId = monitor.startOperation(
        BusinessOperationType.TENANT_CREATE,
        {
          tenantName: 'Acme Corporation',
          domain: 'acme.example.com',
          plan: 'enterprise'
        },
        'admin-user-123'
      );

      // Track validation steps
      monitor.addCheckpoint(createOpId, 'data_validation');
      monitor.addCheckpoint(createOpId, 'domain_verification');
      monitor.addCheckpoint(createOpId, 'database_record_created');
      monitor.addCheckpoint(createOpId, 'default_settings_applied');
      monitor.addCheckpoint(createOpId, 'notification_sent');

      // Complete successfully
      monitor.completeOperation(createOpId, true, undefined, undefined, {
        tenantId: 'tenant-123',
        initialUsers: 1,
        storageAllocated: '10GB'
      });

      // Log audit event
      await auditLogger.log(AuditEventType.TENANT_CREATED, 'New tenant created successfully', {}, {
          tenantId: 'tenant-123',
          tenantName: 'Acme Corporation',
          createdBy: 'admin-user-123'
        }
       ? {
          tenantId: 'tenant-123',
          tenantName: 'Acme Corporation',
          createdBy: 'admin-user-123'
        }
       : {}, { severity: AuditSeverity.medium.toUpperCase() });

      const summary = monitor.getOperationSummary(BusinessOperationType.TENANT_CREATE);
      expect(summary.averageDuration).toBeDefined();
      expect(summary.successRate).toBeGreaterThan(0);
    });

    test('should handle tenant update operations', async () => {
      const monitor = getBusinessMonitor();
      const auditLogger = getAuditLogger();
      
      const updateOpId = monitor.startOperation(
        BusinessOperationType.TENANT_UPDATE,
        {
          tenantId: 'tenant-123',
          changes: { plan: 'professional', maxUsers: 50 }
        },
        'admin-user-123'
      );

      monitor.addCheckpoint(updateOpId, 'changes_validated');
      monitor.addCheckpoint(updateOpId, 'billing_updated');
      monitor.addCheckpoint(updateOpId, 'limits_applied');

      monitor.completeOperation(updateOpId, true);

      await auditLogger.log(AuditEventType.DATA_UPDATED, 'Tenant configuration updated', {}, {
          tenantId: 'tenant-123',
          changedFields: ['plan', 'maxUsers'],
          oldValues: { plan: 'enterprise', maxUsers: 500 },
          newValues: { plan: 'professional', maxUsers: 50 }
        }
       ? {
          tenantId: 'tenant-123',
          changedFields: ['plan', 'maxUsers'],
          oldValues: { plan: 'enterprise', maxUsers: 500 },
          newValues: { plan: 'professional', maxUsers: 50 }
        }
       : {}, { severity: AuditSeverity.medium.toUpperCase() });

      const summary = monitor.getOperationSummary(BusinessOperationType.TENANT_UPDATE);
      expect(summary.totalOperations).toBeGreaterThanOrEqual(1);
    });
  });

  describe('MFA Setup and Usage Workflow', () => {
    test('should track MFA setup process', async () => {
      const monitor = getBusinessMonitor();
      const mfaService = getMFAService();
      
      const mfaSetupOpId = monitor.startOperation(
        BusinessOperationType.USER_CREATE,
        { operation: 'mfa_setup', method: MFAMethod.TOTP },
        'user-123'
      );

      // Mock the setup process
      monitor.addCheckpoint(mfaSetupOpId, 'secret_generated');
      monitor.addCheckpoint(mfaSetupOpId, 'qr_code_created');
      monitor.addCheckpoint(mfaSetupOpId, 'user_verification');
      monitor.addCheckpoint(mfaSetupOpId, 'backup_codes_generated');

      // Test TOTP validation
      const isValidCode = mfaService.validateTOTPCode('123456');
      expect(isValidCode).toBe(true);

      monitor.completeOperation(mfaSetupOpId, true, undefined, undefined, {
        mfaMethod: MFAMethod.TOTP,
        backupCodesGenerated: 8
      });

      const summary = monitor.getOperationSummary(BusinessOperationType.USER_CREATE);
      expect(summary.totalOperations).toBeGreaterThanOrEqual(1);
    });

    test('should handle MFA verification flow', async () => {
      const monitor = getBusinessMonitor();
      const mfaService = getMFAService();
      
      const verificationOpId = monitor.startOperation(
        BusinessOperationType.USER_CREATE,
        { operation: 'mfa_verification' },
        'user-123'
      );

      // Test different code formats
      expect(mfaService.validateTOTPCode('000000')).toBe(true);
      expect(mfaService.validateTOTPCode('abcd')).toBe(false);
      expect(mfaService.validateBackupCode('BACKUP01')).toBe(true);

      monitor.completeOperation(verificationOpId, true);

      const summary = monitor.getOperationSummary(BusinessOperationType.USER_CREATE);
      expect(summary.successRate).toBeGreaterThan(0);
    });
  });

  describe('Dashboard and Analytics Workflow', () => {
    test('should track dashboard loading performance', async () => {
      const monitor = getBusinessMonitor();
      
      const dashboardOpId = monitor.startOperation(
        BusinessOperationType.DASHBOARD_LOAD,
        { userId: 'user-123', widgets: 6 },
        'user-123'
      );

      // Simulate dashboard component loading
      monitor.addCheckpoint(dashboardOpId, 'user_data_fetched');
      monitor.addCheckpoint(dashboardOpId, 'metrics_calculated');
      monitor.addCheckpoint(dashboardOpId, 'charts_rendered');
      monitor.addCheckpoint(dashboardOpId, 'real_time_connected');

      monitor.completeOperation(dashboardOpId, true, undefined, undefined, {
        widgetsLoaded: 6,
        dataPointsDisplayed: 42,
        cacheHitRate: 0.85
      });

      const summary = monitor.getOperationSummary(BusinessOperationType.DASHBOARD_LOAD);
      expect(summary.averageDuration).toBeLessThan(5000); // Should load within 5 seconds
    });

    test('should track analytics operations', async () => {
      const monitor = getBusinessMonitor();
      
      const analyticsOpId = monitor.startOperation(
        BusinessOperationType.DATA_EXPORT,
        { exportType: 'tenant_report', format: 'csv' },
        'admin-user-123'
      );

      monitor.addCheckpoint(analyticsOpId, 'data_queried');
      monitor.addCheckpoint(analyticsOpId, 'data_processed');
      monitor.addCheckpoint(analyticsOpId, 'file_generated');

      monitor.completeOperation(analyticsOpId, true, undefined, undefined, {
        recordsExported: 1247,
        fileSize: '2.3MB',
        compressionRatio: 0.65
      });

      const summary = monitor.getOperationSummary(BusinessOperationType.DATA_EXPORT);
      expect(summary.totalOperations).toBeGreaterThanOrEqual(1);
    });
  });

  describe('PWA and Offline Workflow', () => {
    test('should handle offline functionality', () => {
      const pwa = getPWAManager();
      
      // Test PWA capabilities
      const capabilities = pwa.getCapabilities();
      expect(capabilities).toHaveProperty('serviceWorker');
      expect(capabilities).toHaveProperty('pushNotifications');
      expect(capabilities).toHaveProperty('backgroundSync');

      // Test offline detection
      const isOnline = pwa.isOnlineStatus();
      expect(typeof isOnline).toBe('boolean');

      // Test sync queue
      pwa.addToSyncQueue('tenant_update', {
        endpoint: '/api/v1/tenants/123',
        method: 'PATCH',
        data: { status: 'active' }
      });

      // Sync queue should have items
      const stats = { pendingItems: 1 };
      expect(stats.pendingItems).toBeGreaterThanOrEqual(1);
    });
  });

  describe('System Health and Monitoring', () => {
    test('should monitor overall system performance', () => {
      const monitor = getBusinessMonitor();
      
      // Simulate multiple operations
      const operations = [
        BusinessOperationType.LOGIN_ATTEMPT,
        BusinessOperationType.DASHBOARD_LOAD,
        BusinessOperationType.TENANT_CREATE,
        BusinessOperationType.DATA_EXPORT
      ];

      operations.forEach((opType, index) => {
        const opId = monitor.startOperation(opType, { test: true }, `user-${index}`);
        monitor.completeOperation(opId, true);
      });

      // Check system health
      const health = monitor.getSystemHealth();
      expect(health).toHaveProperty('status');
      expect(health).toHaveProperty('overallPerformance');
      expect(health).toHaveProperty('criticalOperations');
    });

    test('should identify performance bottlenecks', () => {
      const monitor = getBusinessMonitor();
      
      // Simulate slow operation
      const slowOpId = monitor.startOperation(
        BusinessOperationType.TENANT_CREATE,
        { slowOperation: true },
        'user-123'
      );

      // Add artificial delay simulation
      monitor.addCheckpoint(slowOpId, 'slow_checkpoint_1');
      monitor.addCheckpoint(slowOpId, 'slow_checkpoint_2');
      
      monitor.completeOperation(slowOpId, true, undefined, undefined, {
        processingTime: 8000 // 8 seconds
      });

      const summary = monitor.getOperationSummary(BusinessOperationType.TENANT_CREATE);
      expect(summary.averageDuration).toBeGreaterThan(0);
    });
  });

  describe('Error Recovery Workflows', () => {
    test('should handle and recover from API failures', async () => {
      const monitor = getBusinessMonitor();
      const auditLogger = getAuditLogger();
      
      const failureOpId = monitor.startOperation(
        BusinessOperationType.TENANT_UPDATE,
        { tenantId: 'tenant-123' },
        'user-123'
      );

      // Simulate API failure
      monitor.completeOperation(
        failureOpId,
        false,
        'Database connection failed',
        'DB_CONNECTION_ERROR',
        { retryCount: 3 }
      );

      // Log the failure
      await auditLogger.log(AuditEventType.SYSTEM_ERROR, 'Database connection failure during tenant update', {}, {
          operationId: failureOpId,
          errorCode: 'DB_CONNECTION_ERROR',
          retryCount: 3
        }
       ? {
          operationId: failureOpId,
          errorCode: 'DB_CONNECTION_ERROR',
          retryCount: 3
        }
       : {}, { severity: AuditSeverity.critical.toUpperCase() });

      const summary = monitor.getOperationSummary(BusinessOperationType.TENANT_UPDATE);
      expect(summary.totalOperations).toBeGreaterThanOrEqual(1);
    });

    test('should track retry mechanisms', async () => {
      const monitor = getBusinessMonitor();
      
      // Simulate multiple retry attempts
      for (let attempt = 1; attempt <= 3; attempt++) {
        const retryOpId = monitor.startOperation(
          BusinessOperationType.DATA_EXPORT,
          { attempt, retryOperation: true },
          'user-123'
        );

        const success = attempt === 3; // Success on final attempt
        monitor.completeOperation(
          retryOpId,
          success,
          success ? undefined : 'Temporary failure',
          success ? undefined : 'RETRY_NEEDED'
        );
      }

      const summary = monitor.getOperationSummary(BusinessOperationType.DATA_EXPORT);
      expect(summary.totalOperations).toBe(3);
      expect(summary.successRate).toBeGreaterThan(0);
    });
  });
});
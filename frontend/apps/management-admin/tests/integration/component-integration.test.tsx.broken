/**
 * Component Integration Tests
 * Tests how components work together with real services
 */

import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// Import components to test
import { MFASetup } from '../../src/components/auth/MFASetup';
import { RealtimeDashboard } from '../../src/components/realtime/RealtimeDashboard';
import { TenantManagement } from '../../src/components/tenant/TenantManagement';

// Test wrapper with providers
const TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('Component Integration Tests', () => {
  beforeEach(() => {
    // Reset any stored state
    localStorage.clear();
    sessionStorage.clear();
    
    // Mock fetch globally for tests
    global.fetch = jest.fn();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('MFA Setup Integration', () => {
    test('should render MFA setup component', async () => {
      // Mock MFA config API
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        status: 404,
        json: async () => ({ message: 'MFA not configured' })
      });

      render(
        <TestWrapper>
          <MFASetup />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(screen.getByText(/Set up Multi-Factor Authentication/i)).toBeInTheDocument();
      });
    });

    test('should show method selection', async () => {
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        status: 404,
        json: async () => ({ message: 'MFA not configured' })
      });

      render(
        <TestWrapper>
          <MFASetup />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(screen.getByText(/Authenticator App/i)).toBeInTheDocument();
        expect(screen.getByText(/SMS Verification/i)).toBeInTheDocument();
      });
    });

    test('should handle already enabled MFA', async () => {
      // Mock MFA as already enabled
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          userId: 'user-123',
          primaryMethod: 'totp',
          enabledMethods: ['totp'],
          status: 'enabled',
          backupCodesRemaining: 8,
          lastUsed: null,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        })
      });

      render(
        <TestWrapper>
          <MFASetup />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(screen.getByText(/MFA is Already Enabled/i)).toBeInTheDocument();
      });
    });
  });

  describe('Realtime Dashboard Integration', () => {
    beforeEach(() => {
      // Mock WebSocket
      global.WebSocket = jest.fn().mockImplementation(() => ({
        readyState: 1,
        send: jest.fn(),
        close: jest.fn(),
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
      })) as any;
    });

    test('should render realtime dashboard', () => {
      render(
        <TestWrapper>
          <RealtimeDashboard />
        </TestWrapper>
      );

      expect(screen.getByText(/Real-time Connection/i)).toBeInTheDocument();
    });

    test('should show connection status', () => {
      render(
        <TestWrapper>
          <RealtimeDashboard />
        </TestWrapper>
      );

      // Should show connection controls
      expect(screen.getByText(/Connect/i)).toBeInTheDocument();
      expect(screen.getByText(/Disconnect/i)).toBeInTheDocument();
    });

    test('should display metrics grid', () => {
      render(
        <TestWrapper>
          <RealtimeDashboard />
        </TestWrapper>
      );

      // Should have metrics container
      const metricsSection = screen.getByTestId ? 
        screen.queryByTestId('metrics-grid') : 
        document.querySelector('[data-testid="metrics-grid"]');
      
      // Component should render even without test IDs
      expect(screen.getByText(/Real-time Connection/i)).toBeInTheDocument();
    });
  });

  describe('Tenant Management Integration', () => {
    test('should render tenant management component', async () => {
      // Mock tenant list API
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          tenants: [],
          total: 0,
          page: 1,
          limit: 10
        })
      });

      render(
        <TestWrapper>
          <TenantManagement />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(screen.getByText(/Tenant Management/i)).toBeInTheDocument();
      });
    });

    test('should handle API errors gracefully', async () => {
      // Mock API error
      (global.fetch as jest.Mock).mockRejectedValueOnce(
        new Error('API Error')
      );

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      render(
        <TestWrapper>
          <TenantManagement />
        </TestWrapper>
      );

      // Component should still render
      expect(screen.getByText(/Tenant Management/i)).toBeInTheDocument();

      consoleSpy.mockRestore();
    });
  });

  describe('Error Boundary Integration', () => {
    test('should handle component errors gracefully', () => {
      const ThrowError: React.FC = () => {
        throw new Error('Test error');
      };

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      // This would normally be wrapped with an ErrorBoundary in real app
      expect(() => {
        render(
          <TestWrapper>
            <ThrowError />
          </TestWrapper>
        );
      }).toThrow('Test error');

      consoleSpy.mockRestore();
    });
  });

  describe('State Management Integration', () => {
    test('should handle form state correctly', async () => {
      // Mock successful MFA setup
      (global.fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: false,
          status: 404,
          json: async () => ({ message: 'MFA not configured' })
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            secret: 'TESTSECRET',
            qrCodeUrl: 'otpauth://totp/test',
            manualEntryCode: 'TESTSECRET',
            backupCodes: []
          })
        });

      render(
        <TestWrapper>
          <MFASetup />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(screen.getByText(/Authenticator App/i)).toBeInTheDocument();
      });

      // Click authenticator app option
      const authenticatorButton = screen.getByText(/Authenticator App/i).closest('button');
      if (authenticatorButton) {
        fireEvent.click(authenticatorButton);

        await waitFor(() => {
          expect(screen.getByText(/Set up Authenticator App/i)).toBeInTheDocument();
        });
      }
    });
  });

  describe('Performance Integration', () => {
    test('components should render within reasonable time', async () => {
      const startTime = Date.now();

      // Mock APIs to respond quickly
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => ({})
      });

      render(
        <TestWrapper>
          <MFASetup />
        </TestWrapper>
      );

      await waitFor(() => {
        expect(screen.getByText(/Multi-Factor Authentication/i)).toBeInTheDocument();
      });

      const renderTime = Date.now() - startTime;
      
      // Should render within 1 second
      expect(renderTime).toBeLessThan(1000);
    });

    test('should handle multiple rapid re-renders', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => ({
          tenants: [],
          total: 0
        })
      });

      const { rerender } = render(
        <TestWrapper>
          <TenantManagement />
        </TestWrapper>
      );

      // Trigger multiple re-renders
      for (let i = 0; i < 5; i++) {
        rerender(
          <TestWrapper>
            <TenantManagement />
          </TestWrapper>
        );
      }

      await waitFor(() => {
        expect(screen.getByText(/Tenant Management/i)).toBeInTheDocument();
      });
    });
  });

  describe('Accessibility Integration', () => {
    test('components should have proper ARIA attributes', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 404,
        json: async () => ({})
      });

      render(
        <TestWrapper>
          <MFASetup />
        </TestWrapper>
      );

      await waitFor(() => {
        // Check for proper heading structure
        const heading = screen.getByRole('heading');
        expect(heading).toBeInTheDocument();
        
        // Check for proper button roles
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(0);
      });
    });
  });
});
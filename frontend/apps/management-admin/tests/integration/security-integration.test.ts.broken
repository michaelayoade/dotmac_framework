/**
 * Security Integration Tests
 * Tests security features and their integration with the application
 */

import { getMFAService, MFAMethod } from '../../src/lib/mfa-service';
import { getAuditLogger, AuditEventType } from '../../src/lib/audit-logger';

// Mock crypto API for testing
const mockCrypto = {
  subtle: {
    digest: jest.fn().mockResolvedValue(new ArrayBuffer(32)),
  },
  getRandomValues: jest.fn((arr) => {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = Math.floor(Math.random() * 256);
    }
    return arr;
  }),
};

Object.defineProperty(window, 'crypto', {
  value: mockCrypto,
  configurable: true,
});

describe('Security Integration Tests', () => {
  beforeEach(() => {
    localStorage.clear();
    sessionStorage.clear();
    jest.clearAllMocks();
  });

  describe('Authentication Security', () => {
    test('should enforce secure authentication flows', () => {
      const mfaService = getMFAService();
      
      // Test device fingerprinting
      expect(mfaService.isDeviceTrusted()).toBe(false);
      
      // Test code validation security
      expect(mfaService.validateTOTPCode('123456')).toBe(true);
      expect(mfaService.validateTOTPCode('000000')).toBe(true);
      
      // Should reject malformed codes
      expect(mfaService.validateTOTPCode('')).toBe(false);
      expect(mfaService.validateTOTPCode('abc123')).toBe(false);
      expect(mfaService.validateTOTPCode('1234567')).toBe(false);
    });

    test('should handle backup code security', () => {
      const mfaService = getMFAService();
      
      // Valid backup codes
      expect(mfaService.validateBackupCode('ABCD1234')).toBe(true);
      expect(mfaService.validateBackupCode('abcd1234')).toBe(true); // Case insensitive
      
      // Invalid backup codes
      expect(mfaService.validateBackupCode('')).toBe(false);
      expect(mfaService.validateBackupCode('123')).toBe(false);
      expect(mfaService.validateBackupCode('TOOLONG123')).toBe(false);
      expect(mfaService.validateBackupCode('ABCD-123')).toBe(false); // No special chars
    });

    test('should generate secure device fingerprints', () => {
      const mfaService = getMFAService();
      
      // Device fingerprinting should work
      expect(mfaService.isDeviceTrusted()).toBe(false);
      
      // Multiple calls should be consistent
      const trusted1 = mfaService.isDeviceTrusted();
      const trusted2 = mfaService.isDeviceTrusted();
      expect(trusted1).toBe(trusted2);
    });
  });

  describe('Session Security', () => {
    test('should handle session storage securely', () => {
      const testData = { secret: 'test-secret', timestamp: Date.now() };
      
      // Store sensitive data
      sessionStorage.setItem('test_session', JSON.stringify(testData));
      
      // Should be able to retrieve
      const retrieved = JSON.parse(sessionStorage.getItem('test_session') || '{}');
      expect(retrieved.secret).toBe('test-secret');
      
      // Clear should work
      sessionStorage.clear();
      expect(sessionStorage.getItem('test_session')).toBeNull();
    });

    test('should validate token expiration', () => {
      // Mock expired token
      const expiredToken = btoa(JSON.stringify({
        exp: Math.floor(Date.now() / 1000) - 3600 // 1 hour ago
      }));
      
      localStorage.setItem('mfa_trust_token', `header.${expiredToken}.signature`);
      
      const mfaService = getMFAService();
      expect(mfaService.isDeviceTrusted()).toBe(false);
    });

    test('should handle malformed tokens gracefully', () => {
      // Set malformed token
      localStorage.setItem('mfa_trust_token', 'invalid.token.format');
      
      const mfaService = getMFAService();
      expect(mfaService.isDeviceTrusted()).toBe(false);
      
      // Should clean up invalid token
      expect(localStorage.getItem('mfa_trust_token')).toBeNull();
    });
  });

  describe('Audit Trail Security', () => {
    test('should log security events with proper compliance flags', async () => {
      const auditLogger = getAuditLogger();
      
      // Test login event
      const loginEventId = await auditLogger.log(AuditEventType.USER_LOGIN, 'User logged in successfully', {}, { userId: 'user-123', authMethod: 'mfa' }
       ? { userId: 'user-123', authMethod: 'mfa' }
       : {}, { severity: AuditSeverity.low.toUpperCase() });
      
      expect(loginEventId).toBeDefined();
      expect(typeof loginEventId).toBe('string');
    });

    test('should flag security violations appropriately', async () => {
      const auditLogger = getAuditLogger();
      
      // Test security violation
      const violationEventId = await auditLogger.log(AuditEventType.SECURITY_VIOLATION, 'Multiple failed login attempts', {}, {
          userId: 'attacker-123',
          attempts: 5,
          ipAddress: '192.168.1.100'
        }
       ? {
          userId: 'attacker-123',
          attempts: 5,
          ipAddress: '192.168.1.100'
        }
       : {}, { severity: AuditSeverity.critical.toUpperCase() });
      
      expect(violationEventId).toBeDefined();
    });

    test('should handle sensitive data in audit logs', async () => {
      const auditLogger = getAuditLogger();
      
      // Data with potentially sensitive information
      const eventData = {
        userId: 'user-123',
        email: 'user@example.com',
        password: 'should-not-be-logged', // This should be filtered
        creditCard: '4111-1111-1111-1111' // This should be masked
      };
      
      const eventId = await auditLogger.log(AuditEventType.USER_LOGIN, 'User authentication event', {}, eventData
       ? eventData
       : {}, { severity: AuditSeverity.medium.toUpperCase() });
      
      expect(eventId).toBeDefined();
    });
  });

  describe('Data Protection', () => {
    test('should handle GDPR compliance requirements', async () => {
      const auditLogger = getAuditLogger();
      
      // Log data deletion event
      const deletionEventId = await auditLogger.log(AuditEventType.DATA_DELETED, 'User data deleted per GDPR request', {}, {
          userId: 'user-123',
          dataTypes: ['profile', 'activity_logs', 'preferences'],
          requestId: 'gdpr-123',
          requesterEmail: 'user@example.com'
        }
       ? {
          userId: 'user-123',
          dataTypes: ['profile', 'activity_logs', 'preferences'],
          requestId: 'gdpr-123',
          requesterEmail: 'user@example.com'
        }
       : {}, { severity: AuditSeverity.high.toUpperCase() });
      
      expect(deletionEventId).toBeDefined();
    });

    test('should track data access events', async () => {
      const auditLogger = getAuditLogger();
      
      const accessEventId = await auditLogger.log(AuditEventType.DATA_READ, 'Sensitive data accessed', {}, {
          userId: 'admin-123',
          dataType: 'tenant_financial_records',
          tenantId: 'tenant-456',
          accessReason: 'monthly_audit'
        }
       ? {
          userId: 'admin-123',
          dataType: 'tenant_financial_records',
          tenantId: 'tenant-456',
          accessReason: 'monthly_audit'
        }
       : {}, { severity: AuditSeverity.medium.toUpperCase() });
      
      expect(accessEventId).toBeDefined();
    });

    test('should enforce data retention policies', async () => {
      const auditLogger = getAuditLogger();
      
      // Create events with different severities
      await auditLogger.log(AuditEventType.USER_LOGIN, 'Low severity event', {},  ?  : {}, { severity: AuditSeverity.low.toUpperCase() });
      await auditLogger.log(AuditEventType.SECURITY_VIOLATION, 'High severity event', {},  ?  : {}, { severity: AuditSeverity.high.toUpperCase() });
      await auditLogger.log(AuditEventType.SYSTEM_ERROR, 'Critical event', {},  ?  : {}, { severity: AuditSeverity.critical.toUpperCase() });
      
      // Events should be created with appropriate retention periods
      // (Implementation would vary based on actual retention logic)
    });
  });

  describe('Input Validation Security', () => {
    test('should validate MFA codes securely', () => {
      const mfaService = getMFAService();
      
      // Valid codes
      expect(mfaService.validateTOTPCode('123456')).toBe(true);
      expect(mfaService.validateTOTPCode('000000')).toBe(true);
      expect(mfaService.validateTOTPCode('999999')).toBe(true);
      
      // Invalid codes - wrong length
      expect(mfaService.validateTOTPCode('12345')).toBe(false);
      expect(mfaService.validateTOTPCode('1234567')).toBe(false);
      
      // Invalid codes - non-numeric
      expect(mfaService.validateTOTPCode('abcdef')).toBe(false);
      expect(mfaService.validateTOTPCode('123abc')).toBe(false);
      
      // Invalid codes - empty/null
      expect(mfaService.validateTOTPCode('')).toBe(false);
      expect(mfaService.validateTOTPCode(' ')).toBe(false);
    });

    test('should sanitize audit log inputs', async () => {
      const auditLogger = getAuditLogger();
      
      // Try to inject malicious data
      const maliciousData = {
        userId: '<script>alert("xss")</script>',
        description: 'User login with <img src="x" onerror="alert(1)">',
        data: {
          normalField: 'safe data',
          maliciousField: '${process.env.SECRET_KEY}',
          sqlInjection: "'; DROP TABLE users; --"
        }
      };
      
      const eventId = await auditLogger.log(AuditEventType.USER_LOGIN, maliciousData.description, {}, maliciousData
       ? maliciousData
       : {}, { severity: AuditSeverity.low.toUpperCase() });
      
      // Should still create event but sanitize the data
      expect(eventId).toBeDefined();
    });
  });

  describe('Rate Limiting and Abuse Protection', () => {
    test('should handle multiple MFA attempts', () => {
      const mfaService = getMFAService();
      
      // Simulate multiple rapid attempts
      const attempts = [];
      for (let i = 0; i < 10; i++) {
        attempts.push(mfaService.validateTOTPCode('000000'));
      }
      
      // All should succeed in test environment
      // In production, rate limiting would apply
      expect(attempts.every(result => result === true)).toBe(true);
    });

    test('should track failed authentication attempts', async () => {
      const auditLogger = getAuditLogger();
      
      // Log multiple failed attempts
      for (let i = 1; i <= 5; i++) {
        await auditLogger.log(AuditEventType.SECURITY_VIOLATION, `Failed login attempt ${i}`, {}, {
            userId: 'attacker-123',
            attempt: i,
            ipAddress: '192.168.1.100'
          }
         ? {
            userId: 'attacker-123',
            attempt: i,
            ipAddress: '192.168.1.100'
          }
         : {}, { severity: AuditSeverity.medium.toUpperCase() });
      }
      
      // Should have logged all attempts
      // In production, this would trigger security measures
    });
  });

  describe('Encryption and Cryptography', () => {
    test('should use secure random values', () => {
      const values1 = new Uint8Array(32);
      const values2 = new Uint8Array(32);
      
      mockCrypto.getRandomValues(values1);
      mockCrypto.getRandomValues(values2);
      
      // Should generate different values
      expect(values1).not.toEqual(values2);
      
      // Should fill the entire array
      expect(values1.every(v => v >= 0 && v <= 255)).toBe(true);
      expect(values2.every(v => v >= 0 && v <= 255)).toBe(true);
    });

    test('should handle cryptographic operations', async () => {
      const testData = new TextEncoder().encode('test data');
      
      const hash = await mockCrypto.subtle.digest('SHA-256', testData);
      
      expect(hash).toBeInstanceOf(ArrayBuffer);
      expect(hash.byteLength).toBe(32); // SHA-256 produces 32 bytes
    });
  });

  describe('Security Headers and CSP', () => {
    test('should handle secure content policies', () => {
      // In a real browser environment, these would be enforced by CSP headers
      // Here we test that our code doesn't rely on eval or inline scripts
      
      // Should not use eval
      expect(() => {
        // This would be blocked by CSP in production
        // eval('console.log("test")');
      }).not.toThrow();
      
      // Should handle nonces properly (mocked in test environment)
      const mockNonce = 'test-nonce-123';
      expect(mockNonce).toBeDefined();
    });
  });

  describe('Security Configuration', () => {
    test('should use secure defaults', () => {
      const mfaService = getMFAService();
      
      // Should start in secure state
      expect(mfaService.isDeviceTrusted()).toBe(false);
      
      // Should validate all input strictly
      expect(mfaService.validateTOTPCode('')).toBe(false);
      expect(mfaService.validateBackupCode('')).toBe(false);
    });

    test('should handle environment-specific security', () => {
      const env = process.env.NODE_ENV || 'test';
      
      // Different security settings based on environment
      expect(['development', 'test', 'production']).toContain(env);
      
      // In test environment, some security checks might be relaxed
      if (env === 'test') {
        expect(true).toBe(true); // Placeholder for test-specific assertions
      }
    });
  });
});
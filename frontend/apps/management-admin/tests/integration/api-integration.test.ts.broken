/**
 * API Integration Tests
 * Tests the actual API endpoints with real HTTP requests
 */

import { getMFAService } from '../../src/lib/mfa-service';
import { getWebSocketClient } from '../../src/lib/websocket-client';
import { getAuditLogger } from '../../src/lib/audit-logger';

describe('API Integration Tests', () => {
  const baseURL = process.env.INTEGRATION_TEST_API_URL || 'http://localhost:8000';

  beforeEach(() => {
    // Reset any stored state
    localStorage.clear();
    sessionStorage.clear();
  });

  describe('Authentication API', () => {
    test('should handle login flow', async () => {
      const response = await fetch(`${baseURL}/api/auth/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'testpassword123'
        })
      });

      // Should return 200 or 401 depending on test environment
      expect([200, 401, 404]).toContain(response.status);
    });

    test('should handle CSRF token endpoint', async () => {
      const response = await fetch(`${baseURL}/api/auth/csrf`, {
        method: 'GET',
      });

      // Should return 200 or 404 depending on implementation
      expect([200, 404]).toContain(response.status);
    });
  });

  describe('MFA API Integration', () => {
    test('should handle MFA config requests', async () => {
      const mfaService = getMFAService();

      try {
        const config = await mfaService.getMFAConfiguration();
        // Config can be null if not set up
        expect(config).toBeNull();
      } catch (error) {
        // API might not be available in test environment
        expect(error).toBeInstanceOf(Error);
      }
    });

    test('should validate TOTP codes', () => {
      const mfaService = getMFAService();
      
      expect(mfaService.validateTOTPCode('123456')).toBe(true);
      expect(mfaService.validateTOTPCode('12345')).toBe(false);
      expect(mfaService.validateTOTPCode('abcdef')).toBe(false);
    });

    test('should validate backup codes', () => {
      const mfaService = getMFAService();
      
      expect(mfaService.validateBackupCode('ABCD1234')).toBe(true);
      expect(mfaService.validateBackupCode('abcd1234')).toBe(true); // Should normalize
      expect(mfaService.validateBackupCode('123')).toBe(false);
    });
  });

  describe('WebSocket Integration', () => {
    test('should initialize WebSocket client', () => {
      const wsClient = getWebSocketClient();
      
      expect(wsClient).toBeDefined();
      expect(wsClient.getConnectionState()).toBe('disconnected');
      expect(typeof wsClient.connect).toBe('function');
      expect(typeof wsClient.disconnect).toBe('function');
    });

    test('should handle connection statistics', () => {
      const wsClient = getWebSocketClient();
      const stats = wsClient.getConnectionStats();
      
      expect(stats).toHaveProperty('state');
      expect(stats).toHaveProperty('reconnectAttempts');
      expect(stats).toHaveProperty('queuedMessages');
      expect(stats).toHaveProperty('activeSubscriptions');
      expect(stats).toHaveProperty('uptime');
    });

    test('should manage event subscriptions', () => {
      const wsClient = getWebSocketClient();
      let eventReceived = false;
      
      const unsubscribe = wsClient.subscribe('test_event', () => {
        eventReceived = true;
      });
      
      expect(typeof unsubscribe).toBe('function');
      
      // Cleanup
      unsubscribe();
    });
  });

  describe('Audit Logging Integration', () => {
    test('should log audit events', async () => {
      const auditLogger = getAuditLogger();
      
      const eventId = await auditLogger.log('test_event', 'Integration test event', {}, { testData: true }
       ? { testData: true }
       : {}, { severity: AuditSeverity.low.toUpperCase() });
      
      expect(eventId).toBeDefined();
      expect(typeof eventId).toBe('string');
    });

    test('should handle batch processing', async () => {
      const auditLogger = getAuditLogger();
      
      // Generate multiple events
      const eventIds = await Promise.all([
        auditLogger.log('test_event_1', 'Test 1', {},  ?  : {}, { severity: AuditSeverity.low.toUpperCase() }),
        auditLogger.log('test_event_2', 'Test 2', {},  ?  : {}, { severity: AuditSeverity.low.toUpperCase() }),
        auditLogger.log('test_event_3', 'Test 3', {},  ?  : {}, { severity: AuditSeverity.low.toUpperCase() })
      ]);
      
      expect(eventIds).toHaveLength(3);
      eventIds.forEach(id => {
        expect(typeof id).toBe('string');
      });
      
      // Force batch processing
      auditLogger.log(AuditEventType.SYSTEM_ERROR, "Batch processing", {}, {}, { severity: AuditSeverity.MEDIUM }); // );
    });

    test('should determine compliance flags', () => {
      const auditLogger = getAuditLogger();
      
      // Use reflection to test private method (for testing purposes)
      const determineComplianceFlags = (auditLogger as any).determineComplianceFlags;
      
      if (determineComplianceFlags) {
        const flags = determineComplianceFlags('user_login');
        expect(Array.isArray(flags)).toBe(true);
      }
    });
  });

  describe('System Health Checks', () => {
    test('should check API health endpoint', async () => {
      try {
        const response = await fetch(`${baseURL}/api/health`);
        
        if (response.ok) {
          const health = await response.json();
          expect(health).toHaveProperty('status');
        }
      } catch (error) {
        // API might not be available in test environment
        console.warn('Health endpoint not available:', error);
      }
    });

    test('should validate environment configuration', () => {
      // Check that required environment variables are set for integration tests
      const requiredEnvVars = [
        'NODE_ENV',
        'NEXT_PUBLIC_APP_VERSION'
      ];
      
      requiredEnvVars.forEach(envVar => {
        const value = process.env[envVar];
        expect(value).toBeDefined();
      });
    });
  });

  describe('Performance Integration', () => {
    test('should measure API response times', async () => {
      const startTime = Date.now();
      
      try {
        await fetch(`${baseURL}/api/health`, { method: 'GET' });
        const responseTime = Date.now() - startTime;
        
        // API should respond within 5 seconds
        expect(responseTime).toBeLessThan(5000);
      } catch (error) {
        // API might not be available
        console.warn('Performance test skipped - API not available');
      }
    });

    test('should handle concurrent requests', async () => {
      const promises = Array.from({ length: 5 }, () =>
        fetch(`${baseURL}/api/health`).catch(() => null)
      );
      
      const results = await Promise.all(promises);
      
      // At least some requests should succeed or fail gracefully
      expect(results).toHaveLength(5);
    });
  });

  describe('Error Handling Integration', () => {
    test('should handle network errors gracefully', async () => {
      const mfaService = getMFAService();
      
      // Test with invalid URL
      const originalUrl = (mfaService as any).apiBaseUrl;
      (mfaService as any).apiBaseUrl = 'http://invalid-url-that-does-not-exist';
      
      try {
        await mfaService.getMFAConfiguration();
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
      } finally {
        // Restore original URL
        (mfaService as any).apiBaseUrl = originalUrl;
      }
    });

    test('should handle invalid data gracefully', () => {
      const mfaService = getMFAService();
      
      // Test with invalid TOTP codes
      expect(mfaService.validateTOTPCode('')).toBe(false);
      expect(mfaService.validateTOTPCode('invalid')).toBe(false);
      expect(mfaService.validateTOTPCode('1234567')).toBe(false); // Too long
    });
  });
});
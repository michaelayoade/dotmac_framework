name: ARCHIVED - Deploy to Staging

on:
  workflow_dispatch:
    inputs:
      note:
        description: "This workflow is archived. Update paths before use."
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  KUBECTL_VERSION: "v1.28.0"
  DEPLOYMENT_TIMEOUT: 600
  HEALTH_CHECK_RETRIES: 5

jobs:
  # ===== PRE-DEPLOYMENT VALIDATION =====
  validate-deployment:
    name: Validate Deployment Readiness
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'

    outputs:
      deploy-enabled: ${{ steps.check.outputs.deploy-enabled }}
      services-to-deploy: ${{ steps.check.outputs.services-to-deploy }}
      image-tag: ${{ steps.check.outputs.image-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download CI artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-ready
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Validate deployment readiness
        id: check
        run: |
          if [[ ! -f "deployment-ready.json" ]]; then
            echo "❌ Deployment readiness artifact not found"
            echo "deploy-enabled=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Parse deployment readiness
          READY=$(jq -r '.ready_for_deployment' deployment-ready.json)
          COMMIT=$(jq -r '.commit' deployment-ready.json)

          if [[ "$READY" != "true" ]]; then
            echo "❌ CI pipeline indicates not ready for deployment"
            echo "deploy-enabled=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Validate required secrets
          MISSING_SECRETS=()
          [[ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]] && MISSING_SECRETS+=("AWS_ACCESS_KEY_ID")
          [[ -z "${{ secrets.EKS_CLUSTER_NAME_STAGING }}" ]] && MISSING_SECRETS+=("EKS_CLUSTER_NAME_STAGING")
          [[ -z "${{ secrets.DOCKER_REGISTRY_TOKEN }}" ]] && MISSING_SECRETS+=("DOCKER_REGISTRY_TOKEN")

          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo "❌ Missing required secrets: ${MISSING_SECRETS[*]}"
            echo "deploy-enabled=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Set outputs
          echo "deploy-enabled=true" >> $GITHUB_OUTPUT
          echo "services-to-deploy=all" >> $GITHUB_OUTPUT
          echo "image-tag=${COMMIT}" >> $GITHUB_OUTPUT

          echo "✅ Deployment validation passed"
          echo "📦 Deploying commit: ${COMMIT}"

  # ===== BUILD AND PUSH IMAGES =====
  build-images:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: validate-deployment
    if: needs.validate-deployment.outputs.deploy-enabled == 'true'

    strategy:
      fail-fast: false
      matrix:
        service:
          - name: isp-framework
            context: .
            dockerfile: ./Dockerfile
          - name: management-platform
            context: .
            dockerfile: ./docker/Dockerfile.management
          - name: frontend-admin
            context: ./frontend
            dockerfile: ./frontend/apps/admin/Dockerfile
          - name: frontend-customer
            context: ./frontend
            dockerfile: ./frontend/apps/customer/Dockerfile
          - name: frontend-reseller
            context: ./frontend
            dockerfile: ./frontend/apps/reseller/Dockerfile
          - name: frontend-technician
            context: ./frontend
            dockerfile: ./frontend/apps/technician/Dockerfile
          - name: frontend-tenant-portal
            context: ./frontend
            dockerfile: ./frontend/apps/tenant-portal/Dockerfile
          - name: frontend-management-admin
            context: ./frontend
            dockerfile: ./frontend/apps/management-admin/Dockerfile
          - name: frontend-management-reseller
            context: ./frontend
            dockerfile: ./frontend/apps/management-reseller/Dockerfile

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.DOCKER_REGISTRY_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.service.name }}
          tags: |
            type=raw,value=${{ needs.validate-deployment.outputs.image-tag }}
            type=raw,value=staging-latest

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            BUILD_VERSION=${{ needs.validate-deployment.outputs.image-tag }}

  # ===== DEPLOY TO STAGING =====
  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    needs: [validate-deployment, build-images]
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME_STAGING }}
          kubectl cluster-info

      - name: Create namespace if not exists
        run: |
          kubectl create namespace staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy infrastructure components
        run: |
          echo "Deploying infrastructure components..."

          # Deploy ConfigMaps and Secrets
          envsubst < k8s/staging/configmap.yaml | kubectl apply -f -
          kubectl apply -f k8s/staging/secrets.yaml

          # Deploy PVCs and Services
          kubectl apply -f k8s/staging/pvc.yaml
          kubectl apply -f k8s/staging/services.yaml

      - name: Deploy backend services
        run: |
          echo "Deploying backend services..."
          export IMAGE_TAG=${{ needs.validate-deployment.outputs.image-tag }}
          export REGISTRY=${{ env.REGISTRY }}
          export REPO_OWNER=${{ github.repository_owner }}

          # Deploy ISP Framework
          envsubst < k8s/staging/deployment-isp.yaml | kubectl apply -f -

          # Deploy Management Platform
          envsubst < k8s/staging/deployment-management.yaml | kubectl apply -f -

      - name: Deploy frontend applications
        run: |
          echo "Deploying frontend applications..."
          export IMAGE_TAG=${{ needs.validate-deployment.outputs.image-tag }}
          export REGISTRY=${{ env.REGISTRY }}
          export REPO_OWNER=${{ github.repository_owner }}

          # Deploy all frontend apps
          for app in admin customer reseller technician tenant-portal management-admin management-reseller; do
            echo "Deploying frontend-${app}..."
            envsubst < k8s/staging/deployment-frontend-${app}.yaml | kubectl apply -f - || \
            envsubst < k8s/staging/deployment-frontend-template.yaml | \
            sed "s/FRONTEND_APP_PLACEHOLDER/${app}/g" | kubectl apply -f -
          done

      - name: Wait for deployments
        run: |
          echo "Waiting for deployments to be ready..."

          # Backend services
          kubectl rollout status deployment/isp-framework -n staging --timeout=${DEPLOYMENT_TIMEOUT}s
          kubectl rollout status deployment/management-platform -n staging --timeout=${DEPLOYMENT_TIMEOUT}s

          # Frontend applications
          for app in admin customer reseller technician tenant-portal management-admin management-reseller; do
            echo "Waiting for frontend-${app}..."
            kubectl rollout status deployment/frontend-${app} -n staging --timeout=${DEPLOYMENT_TIMEOUT}s || true
          done

      - name: Verify deployment health
        run: |
          echo "Verifying deployment health..."
          sleep 30

          # Check pod status
          kubectl get pods -n staging

          # Check for failed pods
          FAILED_PODS=$(kubectl get pods -n staging --field-selector=status.phase=Failed --no-headers | wc -l)
          if [[ $FAILED_PODS -gt 0 ]]; then
            echo "❌ Found $FAILED_PODS failed pods"
            kubectl get pods -n staging --field-selector=status.phase=Failed
            exit 1
          fi

          echo "✅ All pods are healthy"

  # ===== STAGING SMOKE TESTS =====
  smoke-tests:
    name: Staging Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy-staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME_STAGING }}

      - name: Get service endpoints
        id: endpoints
        run: |
          # Get service URLs (using LoadBalancer or NodePort)
          ISP_URL=$(kubectl get service isp-framework -n staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "staging-isp.dotmac.com")
          MGMT_URL=$(kubectl get service management-platform -n staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "staging-mgmt.dotmac.com")

          echo "isp-url=${ISP_URL}" >> $GITHUB_OUTPUT
          echo "mgmt-url=${MGMT_URL}" >> $GITHUB_OUTPUT

          echo "ISP Framework URL: ${ISP_URL}"
          echo "Management Platform URL: ${MGMT_URL}"

      - name: Run health checks
        run: |
          echo "Running health checks..."

          # Wait for services to be ready
          sleep 60

          # Health check with retries
          for i in {1..5}; do
            echo "Health check attempt $i/5..."

            # Check ISP Framework
            if curl -f -s "http://${{ steps.endpoints.outputs.isp-url }}/health" > /dev/null; then
              echo "✅ ISP Framework health check passed"
              ISP_HEALTHY=true
            else
              echo "⚠️  ISP Framework health check failed (attempt $i)"
              ISP_HEALTHY=false
            fi

            # Check Management Platform
            if curl -f -s "http://${{ steps.endpoints.outputs.mgmt-url }}/health" > /dev/null; then
              echo "✅ Management Platform health check passed"
              MGMT_HEALTHY=true
            else
              echo "⚠️  Management Platform health check failed (attempt $i)"
              MGMT_HEALTHY=false
            fi

            if [[ "$ISP_HEALTHY" == "true" && "$MGMT_HEALTHY" == "true" ]]; then
              echo "✅ All services are healthy"
              break
            fi

            if [[ $i -eq 5 ]]; then
              echo "❌ Health checks failed after 5 attempts"
              exit 1
            fi

            sleep 30
          done

      - name: Run API smoke tests
        run: |
          echo "Running API smoke tests..."

          # Test ISP Framework endpoints
          curl -f "http://${{ steps.endpoints.outputs.isp-url }}/api/v1/status" || exit 1

          # Test Management Platform endpoints
          curl -f "http://${{ steps.endpoints.outputs.mgmt-url }}/api/v1/status" || exit 1

          echo "✅ API smoke tests passed"

  # ===== STAGING INTEGRATION TESTS =====
  staging-integration-tests:
    name: Integration Tests on Staging
    runs-on: ubuntu-latest
    needs: smoke-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18.x"

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: "8.x"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./frontend

      - name: Install Playwright
        run: npx playwright install --with-deps
        working-directory: ./frontend

      - name: Run integration tests against staging
        run: |
          # Run integration tests against staging environment
          STAGING_BASE_URL=https://staging.dotmac.com \
          npm run test:integration:staging
        working-directory: ./frontend

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-integration-test-results
          path: |
            frontend/test-results/
            frontend/playwright-report/
          retention-days: 7

  # ===== DEPLOYMENT SUMMARY =====
  deployment-summary:
    name: Staging Deployment Summary
    runs-on: ubuntu-latest
    needs: [deploy-staging, smoke-tests, staging-integration-tests]
    if: always()

    steps:
      - name: Generate deployment summary
        run: |
          echo "=== STAGING DEPLOYMENT SUMMARY ==="
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Commit: ${{ github.sha }}"
          echo "Build: ${{ github.run_number }}"
          echo ""
          echo "Deployment Status: ${{ needs.deploy-staging.result }}"
          echo "Smoke Tests: ${{ needs.smoke-tests.result }}"
          echo "Integration Tests: ${{ needs.staging-integration-tests.result }}"

          if [[ "${{ needs.deploy-staging.result }}" == "success" &&
                "${{ needs.smoke-tests.result }}" == "success" &&
                "${{ needs.staging-integration-tests.result }}" == "success" ]]; then
            echo "✅ Staging deployment successful - ready for production"
            echo "STAGING_READY=true" >> $GITHUB_ENV
          else
            echo "❌ Staging deployment failed or incomplete"
            echo "STAGING_READY=false" >> $GITHUB_ENV
          fi

      - name: Create production readiness artifact
        if: env.STAGING_READY == 'true'
        run: |
          cat > production-ready.json << EOF
          {
            "commit": "${{ github.sha }}",
            "build_number": "${{ github.run_number }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "staging_deployment": "${{ needs.deploy-staging.result }}",
            "smoke_tests": "${{ needs.smoke-tests.result }}",
            "integration_tests": "${{ needs.staging-integration-tests.result }}",
            "ready_for_production": true,
            "staging_url": "https://staging.dotmac.com"
          }
          EOF

      - name: Upload production readiness artifact
        if: env.STAGING_READY == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: production-ready
          path: production-ready.json
          retention-days: 90

      - name: Notify team of staging deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          text: |
            🚀 Staging Deployment Complete

            **Commit:** ${{ github.sha }}
            **Status:** ${{ env.STAGING_READY == 'true' && '✅ Success' || '❌ Failed' }}
            **URL:** https://staging.dotmac.com

            **Results:**
            - Deployment: ${{ needs.deploy-staging.result }}
            - Smoke Tests: ${{ needs.smoke-tests.result }}
            - Integration Tests: ${{ needs.staging-integration-tests.result }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
